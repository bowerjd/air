package com.lonelystorm.air.component.services.impl;

import static org.apache.commons.lang.ArrayUtils.isNotEmpty;
import static org.apache.commons.lang.StringUtils.startsWith;
import static org.apache.commons.lang.StringUtils.substringAfter;

import java.io.IOException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.ConfigurationPolicy;
import org.apache.felix.scr.annotations.Properties;
import org.apache.felix.scr.annotations.Property;
import org.apache.felix.scr.annotations.Service;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.resource.ModifiableValueMap;
import org.apache.sling.api.resource.PersistenceException;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.servlets.post.Modification;
import org.apache.sling.servlets.post.SlingPostProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.lonelystorm.air.component.model.BsonIdentifier;

@Component(
    metatype = true,
    label = "LonelyStorm Air - Component - BSON Post Processor",
    description = "Automatically creates resources when a bson field is detected",
    policy = ConfigurationPolicy.REQUIRE
)
@Service
@Properties({
    @Property(
        name = "bson.active",
        label = "Activate",
        description = "Determines if the bson post processed is enabled or not.",
        boolValue = false
    )
})
public class BsonPostProcessorImpl implements SlingPostProcessor {

    private final static Logger LOGGER = LoggerFactory.getLogger(BsonPostProcessorImpl.class);

    public static final String PREFIX_TAB_NAME = ":lonelystorm.air:bson@";

    @Override
    public void process(SlingHttpServletRequest slingHttpServletRequest, List<Modification> modifications) throws Exception {
        @SuppressWarnings("unchecked")
        Map<String, String[]> parameters = (Map<String, String[]>) slingHttpServletRequest.getParameterMap();
        Resource resource = slingHttpServletRequest.getResource();

        Set<Entry<String, String[]>> entries = parameters.entrySet();
        for (Entry<String, String[]> entry : entries) {
            processKey(resource, entry.getKey(), entry.getValue());
        }
    }

    private void processKey(Resource resource, String key, String[] values) {
        if (startsWith(key, PREFIX_TAB_NAME)) {
            if (values != null && values.length > 0) {
                processBsonKey(resource, substringAfter(key, "@"), values[0]);
            }
        }
    }

    private void processBsonKey(Resource resource, String property, String resourceType) {
        try {
            Set<String> authored = findAuthoredBsonResources(resource, property);
            Set<String> existing = findExistingBsonResources(resource, property);

            Set<String> created = new HashSet<String>(authored);
            created.removeAll(existing);
            existing.removeAll(authored);

            create(resource, property, resourceType, created);
            clean(resource, existing);
            save(resource);
        } catch (PersistenceException e) {
            ResourceResolver resolver = resource.getResourceResolver();
            resolver.revert();

            LOGGER.error("Unable to generate bson resources", e);
        }
    }

    private void create(Resource resource, String property, String resourceType, Set<String> created) throws PersistenceException {
        ResourceResolver resolver = resource.getResourceResolver();

        for (String name : created) {
            Map<String, Object> properties = new TreeMap<String, Object>();
            properties.put("jcr:primaryType", "nt:unstructured");
            properties.put("autoGeneratedBson", true);
            properties.put("sling:resourceType", resourceType);

            resolver.create(resource, name, properties);
        }
    }

    private Set<String> findAuthoredBsonResources(Resource resource, String property) {
        Set<String> names = new HashSet<String>();

        ModifiableValueMap properties = resource.adaptTo(ModifiableValueMap.class);
        String[] identifiers = properties.get(property, String[].class);

        if (isNotEmpty(identifiers)) {
            for (String identifier : identifiers) {

                try {
                    BsonIdentifier bson = BsonIdentifier.fromProperty(identifier);
                    names.add(bson.getBsonId());
                } catch (IOException e) {
                    LOGGER.error("Error converting property to bson identifier", e);
                }
            }
        }

        return names;
    }

    private Set<String> findExistingBsonResources(Resource resource, String property) {
        Set<String> names = new HashSet<String>();

        Iterator<Resource> children = resource.listChildren();
        while (children.hasNext()) {
            Resource child = children.next();
            ModifiableValueMap properties = child.adaptTo(ModifiableValueMap.class);

            if (properties.containsKey("autoGeneratedBson")) {
                names.add(child.getName());
            }
        }

        return names;
    }

    private void clean(Resource resource, Set<String> children) throws PersistenceException {
        ResourceResolver resolver = resource.getResourceResolver();

        for (String name : children) {
            Resource child = resource.getChild(name);
            if (child != null) {
                resolver.delete(child);
            }
        }
    }

    private void save(Resource resource) throws PersistenceException {
        ResourceResolver resolver = resource.getResourceResolver();
        resolver.commit();
    }

}
